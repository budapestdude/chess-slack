// Logger will be imported below, so we'll log startup info after routes are loaded

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import dotenv from 'dotenv';
import { createServer } from 'http';
import { Server } from 'socket.io';

import logger, { stream } from './utils/logger';
import swaggerUi from 'swagger-ui-express';
import swaggerSpec from './config/swagger';
import runMigrations from './database/migrationRunner';

logger.info('ðŸš€ Starting ChessSlack backend...', {
  nodeVersion: process.version,
  workingDirectory: process.cwd()
});
logger.debug('Core modules and logger imported');

logger.debug('Importing routes...');
import type { Router } from 'express';
let authRoutes: Router;
try {
  authRoutes = require('./routes/authRoutes').default;
  logger.debug('authRoutes loaded');
} catch (error) {
  logger.error('Failed to load authRoutes', { error });
  throw error;
}
import workspaceRoutes from './routes/workspaceRoutes';
import channelRoutes from './routes/channelRoutes';
import messageRoutes from './routes/messageRoutes';
import dmRoutes from './routes/dmRoutes';
import userRoutes from './routes/userRoutes';
import notificationRoutes from './routes/notificationRoutes';
import searchRoutes from './routes/searchRoutes';
import invitationRoutes from './routes/invitationRoutes';
import draftRoutes from './routes/draftRoutes';
import uploadRoutes from './routes/uploadRoutes';
import personalRoutes from './routes/personalRoutes';
import documentRoutes from './routes/documentRoutes';
import mindMapRoutes from './routes/mindMapRoutes';
import crmRoutes from './routes/crmRoutes';
import marketingRoutes from './routes/marketingRoutes';
import sprintRoutes from './routes/sprintRoutes';
import meetingNotesRoutes from './routes/meetingNotesRoutes';
import projectRoutes from './routes/projectRoutes';
import taskRoutes from './routes/taskRoutes';
logger.debug('All routes imported successfully');

// Note: Agent system routes are temporarily disabled
// The agent system (AI-powered autonomous task execution) is a feature in development.
// When enabled, these routes provide APIs for:
// - agentRoutes: Creating and managing AI agents
// - taskRoutes: Agent task assignment and tracking
// - artifactRoutes: Code artifacts generated by agents
// Corresponding WebSocket handlers in sockets/agentSocket.ts are also disabled
// import agentRoutes from './routes/agentRoutes';
// import artifactRoutes from './routes/artifactRoutes';

logger.debug('Importing utilities and middleware...');
import { verifyToken } from './utils/jwt';
import pool from './database/db';
import { apiLimiter } from './middleware/rateLimiter';
import { sanitizeInput } from './middleware/sanitize';
import { errorHandler } from './middleware/errorHandler';
import { asyncHandler } from './utils/asyncHandler';
logger.debug('Utilities and middleware imported');
// import { setupAgentSocketHandlers, setupAgentClientHandlers } from './sockets/agentSocket';

logger.debug('Configuring environment...');
dotenv.config();

logger.debug('Creating Express app and HTTP server...');
const app = express();
const httpServer = createServer(app);
logger.debug('Express app and HTTP server created');

// Ensure uploads directory exists
import fs from 'fs';
if (!fs.existsSync('uploads')) {
  fs.mkdirSync('uploads', { recursive: true });
  logger.info('Created uploads directory');
} else {
  logger.debug('Uploads directory already exists');
}

// Parse CORS origins from environment variable (comma-separated) or use defaults
const corsOrigins = process.env.CORS_ORIGIN
  ? process.env.CORS_ORIGIN.split(',').map(origin => origin.trim())
  : ['http://localhost:5173', 'http://localhost:5174'];

logger.info('CORS Configuration', {
  corsOriginEnv: process.env.CORS_ORIGIN,
  allowedOrigins: corsOrigins
});

// Socket.IO setup
const io = new Server(httpServer, {
  cors: {
    origin: corsOrigins,
    methods: ['GET', 'POST'],
    credentials: true,
  },
});

// Setup agent WebSocket event broadcasts
// setupAgentSocketHandlers(io);

// Middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:', 'http://localhost:3001', 'http://localhost:5173', 'http://localhost:5174', 'https://chess-slack-production.up.railway.app'],
      connectSrc: ["'self'", 'http://localhost:3001', 'ws://localhost:3001', 'https://chess-slack-production.up.railway.app', 'wss://chess-slack-production.up.railway.app', ...corsOrigins],
    },
  },
  crossOriginResourcePolicy: { policy: 'cross-origin' },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));
app.use(cors({
  origin: (origin, callback) => {
    logger.debug('CORS check', { incomingOrigin: origin, allowedOrigins: corsOrigins });

    // Allow requests with no origin (like mobile apps, Postman, server-to-server)
    if (!origin) {
      logger.debug('CORS check: No origin header, allowing request');
      return callback(null, true);
    }

    // Check if origin is in the allowed list
    if (corsOrigins.includes(origin)) {
      logger.debug('CORS check: Origin allowed', { origin });
      return callback(null, true);
    }

    logger.warn('CORS check: Origin rejected', { origin });
    return callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
}));
app.use(compression());
app.use(morgan('combined', { stream }));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Apply rate limiting and input sanitization
app.use(apiLimiter);
app.use(sanitizeInput);

// Health check
app.get('/health', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Routes
logger.info('Router registration order: messageRoutes BEFORE channelRoutes');
app.use('/api/auth', authRoutes);
app.use('/api/workspaces', workspaceRoutes);
// Agent system routes disabled (see note above in imports section)
// app.use('/api/workspaces', agentRoutes);
// app.use('/api/workspaces', taskRoutes);
// app.use('/api/workspaces', artifactRoutes);
app.use('/api/workspaces', messageRoutes); // Register before channelRoutes to handle download route first
app.use('/api/workspaces', channelRoutes);
app.use('/api/workspaces', notificationRoutes);
app.use('/api/workspaces', searchRoutes);
app.use('/api/workspaces', invitationRoutes);
app.use('/api/workspaces', draftRoutes);
app.use('/api/workspaces', uploadRoutes);
app.use('/api/workspaces', documentRoutes);
app.use('/api/workspaces', mindMapRoutes);
app.use('/api/personal', personalRoutes);
app.use('/api/crm', crmRoutes);
app.use('/api/marketing', marketingRoutes);
app.use('/api/sprints', sprintRoutes);
app.use('/api/workspaces', meetingNotesRoutes);
app.use('/api', projectRoutes);
app.use('/api', taskRoutes);
app.use('/api/dms', dmRoutes);
app.use('/api/users', userRoutes);

// API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
  customCss: '.swagger-ui .topbar { display: none }',
  customSiteTitle: 'ChessSlack API Docs',
}));
logger.info('Swagger UI available at /api-docs');

// Helper to transform relative avatar URLs to full URLs for cross-origin compatibility
const getFullAvatarUrl = (avatarUrl: string | null): string | null => {
  if (!avatarUrl) return null;
  if (avatarUrl.startsWith('http://') || avatarUrl.startsWith('https://')) {
    return avatarUrl; // Already a full URL
  }
  const baseUrl = process.env.API_BASE_URL || process.env.BACKEND_URL || '';
  return baseUrl ? `${baseUrl}${avatarUrl}` : avatarUrl;
};

// WebSocket authentication middleware
io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;

    if (!token) {
      return next(new Error('Authentication required'));
    }

    const decoded = verifyToken(token);

    // Fetch user from database
    const result = await pool.query(
      'SELECT id, email, username, display_name FROM users WHERE id = $1 AND is_active = true',
      [decoded.userId]
    );

    if (result.rows.length === 0) {
      return next(new Error('User not found'));
    }

    socket.data.user = result.rows[0];
    socket.data.userId = decoded.userId;
    next();
  } catch (error) {
    next(new Error('Authentication failed'));
  }
});

// WebSocket connection handling
io.on('connection', async (socket) => {
  logger.info('WebSocket client connected', { socketId: socket.id, username: socket.data.user?.username });

  const userId = socket.data.userId;

  // Set user as online when they connect
  if (userId) {
    await pool.query(
      `INSERT INTO user_presence (user_id, status, last_activity)
       VALUES ($1, 'online', NOW())
       ON CONFLICT (user_id)
       DO UPDATE SET status = 'online', last_activity = NOW()`,
      [userId]
    );

    // Broadcast presence change to all workspaces
    const workspacesResult = await pool.query(
      'SELECT workspace_id FROM workspace_members WHERE user_id = $1',
      [userId]
    );

    const userResult = await pool.query(
      'SELECT id, username, display_name, avatar_url FROM users WHERE id = $1',
      [userId]
    );

    const user = userResult.rows[0];

    workspacesResult.rows.forEach((row) => {
      io.in(`workspace:${row.workspace_id}`).emit('presence-changed', {
        userId: user.id,
        username: user.username,
        displayName: user.display_name,
        avatarUrl: getFullAvatarUrl(user.avatar_url),
        status: 'online',
      });
    });
  }

  // Setup agent-specific WebSocket handlers for this client
  // setupAgentClientHandlers(socket, userId);

  socket.on('join-workspace', async (workspaceId: string) => {
    // Validate input
    if (!workspaceId || typeof workspaceId !== 'string' || !/^[0-9a-f-]{36}$/i.test(workspaceId)) {
      logger.warn('Invalid workspace ID in join-workspace', { socketId: socket.id, workspaceId });
      return;
    }

    // Verify user is member of workspace
    try {
      const memberCheck = await pool.query(
        'SELECT 1 FROM workspace_members WHERE workspace_id = $1 AND user_id = $2',
        [workspaceId, userId]
      );

      if (memberCheck.rows.length === 0) {
        logger.warn('Unauthorized workspace join attempt', { socketId: socket.id, userId, workspaceId });
        return;
      }

      socket.join(`workspace:${workspaceId}`);
      logger.debug('Socket joined workspace', { socketId: socket.id, workspaceId });
    } catch (error) {
      logger.error('Error in join-workspace', { error, socketId: socket.id });
    }
  });

  // Join user-specific room for personal notifications
  socket.join(`user:${userId}`);
  logger.debug('Socket joined user room', { socketId: socket.id, userId });

  socket.on('join-channel', async (channelId: string, callback?: (success: boolean) => void) => {
    // Validate input
    if (!channelId || typeof channelId !== 'string' || !/^[0-9a-f-]{36}$/i.test(channelId)) {
      logger.warn('Invalid channel ID in join-channel', { socketId: socket.id, channelId });
      if (callback) callback(false);
      return;
    }

    // Verify user is member of channel
    try {
      const memberCheck = await pool.query(
        'SELECT 1 FROM channel_members WHERE channel_id = $1 AND user_id = $2',
        [channelId, userId]
      );

      if (memberCheck.rows.length === 0) {
        logger.warn('Unauthorized channel join attempt', { socketId: socket.id, userId, channelId });
        if (callback) callback(false);
        return;
      }

      socket.join(`channel:${channelId}`);
      logger.debug('Socket joined channel', { socketId: socket.id, channelId });

      // Notify others that user joined
      socket.to(`channel:${channelId}`).emit('user-joined-channel', {
        user: socket.data.user,
        channelId,
      });

      // Acknowledge join completion to sender
      if (callback) {
        callback(true);
      }
    } catch (error) {
      logger.error('Error in join-channel', { error, socketId: socket.id });
      if (callback) callback(false);
    }
  });

  socket.on('leave-channel', (channelId: string) => {
    // Validate input
    if (!channelId || typeof channelId !== 'string' || !/^[0-9a-f-]{36}$/i.test(channelId)) {
      logger.warn('Invalid channel ID in leave-channel', { socketId: socket.id, channelId });
      return;
    }

    socket.leave(`channel:${channelId}`);
    logger.debug('Socket left channel', { socketId: socket.id, channelId });

    // Notify others that user left
    socket.to(`channel:${channelId}`).emit('user-left-channel', {
      user: socket.data.user,
      channelId,
    });
  });

  socket.on('join-dm', async (dmGroupId: string, callback?: (success: boolean) => void) => {
    // Validate input
    if (!dmGroupId || typeof dmGroupId !== 'string' || !/^[0-9a-f-]{36}$/i.test(dmGroupId)) {
      logger.warn('Invalid DM group ID in join-dm', { socketId: socket.id, dmGroupId });
      if (callback) callback(false);
      return;
    }

    // Verify user is member of DM group
    try {
      const memberCheck = await pool.query(
        'SELECT 1 FROM dm_group_members WHERE dm_group_id = $1 AND user_id = $2',
        [dmGroupId, userId]
      );

      if (memberCheck.rows.length === 0) {
        logger.warn('Unauthorized DM join attempt', { socketId: socket.id, userId, dmGroupId });
        if (callback) callback(false);
        return;
      }

      socket.join(`dm:${dmGroupId}`);
      logger.debug('Socket joined DM', { socketId: socket.id, dmGroupId });

      // Acknowledge join completion to sender
      if (callback) {
        callback(true);
      }
    } catch (error) {
      logger.error('Error in join-dm', { error, socketId: socket.id });
      if (callback) callback(false);
    }
  });

  socket.on('leave-dm', (dmGroupId: string) => {
    // Validate input
    if (!dmGroupId || typeof dmGroupId !== 'string' || !/^[0-9a-f-]{36}$/i.test(dmGroupId)) {
      logger.warn('Invalid DM group ID in leave-dm', { socketId: socket.id, dmGroupId });
      return;
    }

    socket.leave(`dm:${dmGroupId}`);
    logger.debug('Socket left DM', { socketId: socket.id, dmGroupId });
  });

  socket.on('typing', ({ channelId }) => {
    // Validate input
    if (!channelId || typeof channelId !== 'string' || !/^[0-9a-f-]{36}$/i.test(channelId)) {
      return;
    }

    socket.to(`channel:${channelId}`).emit('user-typing', {
      user: socket.data.user,
      channelId,
    });
  });

  socket.on('stop-typing', ({ channelId }) => {
    // Validate input
    if (!channelId || typeof channelId !== 'string' || !/^[0-9a-f-]{36}$/i.test(channelId)) {
      return;
    }

    socket.to(`channel:${channelId}`).emit('user-stop-typing', {
      user: socket.data.user,
      channelId,
    });
  });

  // Document collaboration handlers
  socket.on('join-document', async ({ documentId, workspaceId }) => {
    // Validate input
    if (!documentId || !workspaceId ||
        typeof documentId !== 'string' || typeof workspaceId !== 'string' ||
        !/^[0-9a-f-]{36}$/i.test(documentId) || !/^[0-9a-f-]{36}$/i.test(workspaceId)) {
      logger.warn('Invalid document/workspace ID in join-document', { socketId: socket.id, documentId, workspaceId });
      return;
    }

    try {
      // Verify user has access to document
      const accessCheck = await pool.query(
        `SELECT d.id FROM documents d
         LEFT JOIN document_collaborators dc ON d.id = dc.document_id AND dc.user_id = $2
         WHERE d.id = $1 AND d.workspace_id = $3
         AND (d.is_public = true OR d.created_by = $2 OR dc.user_id IS NOT NULL)`,
        [documentId, userId, workspaceId]
      );

      if (accessCheck.rows.length === 0) {
        logger.warn('Unauthorized document join attempt', { socketId: socket.id, userId, documentId });
        return;
      }

      socket.join(`document:${documentId}`);
      logger.debug('Socket joined document', { socketId: socket.id, documentId });

      // Get user info and broadcast join
      const userResult = await pool.query(
        'SELECT id, username, display_name, avatar_url FROM users WHERE id = $1',
        [userId]
      );

      const user = userResult.rows[0];

      socket.to(`document:${documentId}`).emit('collaborator-joined', {
        userId: user.id,
        username: user.username,
        displayName: user.display_name,
        avatarUrl: getFullAvatarUrl(user.avatar_url),
        lastActivity: new Date(),
      });

      // Send current collaborators to new joiner
      const collaborators = await pool.query(
        `SELECT DISTINCT u.id, u.username, u.display_name, u.avatar_url
         FROM users u
         WHERE u.id IN (
           SELECT user_id FROM document_collaborators WHERE document_id = $1
           UNION
           SELECT created_by FROM documents WHERE id = $1
         )`,
        [documentId]
      );

      socket.emit('document-presence', collaborators.rows.map(row => ({
        userId: row.id,
        username: row.username,
        displayName: row.display_name,
        avatarUrl: getFullAvatarUrl(row.avatar_url),
        lastActivity: new Date(),
      })));
    } catch (error) {
      logger.error('Error in join-document', { error, socketId: socket.id });
    }
  });

  socket.on('leave-document', ({ documentId }) => {
    // Validate input
    if (!documentId || typeof documentId !== 'string' || !/^[0-9a-f-]{36}$/i.test(documentId)) {
      logger.warn('Invalid document ID in leave-document', { socketId: socket.id, documentId });
      return;
    }

    socket.leave(`document:${documentId}`);
    logger.debug('Socket left document', { socketId: socket.id, documentId });

    // Notify others
    socket.to(`document:${documentId}`).emit('collaborator-left', userId);
  });

  socket.on('document-update', ({ documentId, content, timestamp }) => {
    // Validate input
    if (!documentId || typeof documentId !== 'string' || !/^[0-9a-f-]{36}$/i.test(documentId)) {
      return;
    }

    // Broadcast update to other users in document
    socket.to(`document:${documentId}`).emit('document-update', {
      documentId,
      content,
      updatedBy: userId,
      timestamp: timestamp || new Date(),
    });
  });

  socket.on('cursor-update', ({ documentId, position }) => {
    // Validate input
    if (!documentId || typeof documentId !== 'string' || !/^[0-9a-f-]{36}$/i.test(documentId)) {
      return;
    }

    // Broadcast cursor position to other users
    socket.to(`document:${documentId}`).emit('cursor-update', {
      userId,
      position,
    });
  });

  socket.on('document-presence', ({ documentId }) => {
    // Validate input
    if (!documentId || typeof documentId !== 'string' || !/^[0-9a-f-]{36}$/i.test(documentId)) {
      return;
    }

    // Broadcast presence heartbeat
    socket.to(`document:${documentId}`).emit('presence-heartbeat', {
      userId,
      timestamp: new Date(),
    });
  });

  socket.on('set-presence', async ({ status }) => {
    const validStatuses = ['online', 'away', 'busy', 'offline'];
    if (!validStatuses.includes(status)) {
      return;
    }

    if (userId) {
      await pool.query(
        `UPDATE user_presence SET status = $1, last_activity = NOW() WHERE user_id = $2`,
        [status, userId]
      );

      // Broadcast presence change
      const workspacesResult = await pool.query(
        'SELECT workspace_id FROM workspace_members WHERE user_id = $1',
        [userId]
      );

      const userResult = await pool.query(
        'SELECT id, username, display_name, avatar_url FROM users WHERE id = $1',
        [userId]
      );

      const user = userResult.rows[0];

      workspacesResult.rows.forEach((row) => {
        io.in(`workspace:${row.workspace_id}`).emit('presence-changed', {
          userId: user.id,
          username: user.username,
          displayName: user.display_name,
          avatarUrl: getFullAvatarUrl(user.avatar_url),
          status,
        });
      });
    }
  });

  socket.on('disconnect', async () => {
    logger.info('WebSocket client disconnected', { socketId: socket.id });

    // Set user as offline when they disconnect
    if (userId) {
      await pool.query(
        `UPDATE user_presence SET status = 'offline', last_activity = NOW() WHERE user_id = $1`,
        [userId]
      );

      // Broadcast presence change
      const workspacesResult = await pool.query(
        'SELECT workspace_id FROM workspace_members WHERE user_id = $1',
        [userId]
      );

      const userResult = await pool.query(
        'SELECT id, username, display_name, avatar_url FROM users WHERE id = $1',
        [userId]
      );

      const user = userResult.rows[0];

      workspacesResult.rows.forEach((row) => {
        io.in(`workspace:${row.workspace_id}`).emit('presence-changed', {
          userId: user.id,
          username: user.username,
          displayName: user.display_name,
          avatarUrl: getFullAvatarUrl(user.avatar_url),
          status: 'offline',
        });
      });
    }
  });
});

// 404 handler (must come before error handler)
app.use((_req, res) => {
  return res.status(404).json({ error: 'Route not found' });
});

// Global error handler (must be last)
app.use(errorHandler);

const PORT = parseInt(process.env.PORT || '3001', 10);

// Run migrations before starting server
runMigrations()
  .then(() => {
    httpServer.listen(PORT, '0.0.0.0', () => {
      global.serverStarted = true;
      logger.info(`Server running on port ${PORT}`);
      logger.info('WebSocket server ready');
      logger.info('ðŸš€ ChessSlack backend successfully started');
    });
  })
  .catch((error) => {
    logger.error('Failed to run migrations, server not started:', error);
    process.exit(1);
  });

export { io };